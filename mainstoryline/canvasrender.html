<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        canvas {
            background-color: #f1f1f1;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: crisp-edges;
            /*image-rendering: pixelated;*/
            height: 98vh;
        }

        * {
            margin: 0px;
            padding: 0px;
        }
    </style>
</head>
<body onload="startGame()">
    <script>var maxClicks = {
            r: 10,
            t4: 5,
            d: 3
        };
        var lim = {
            r: [1, 2],
            t4: [4, 7],
            d: [1, 1]
        };
        var dropitem = {
            r: ['s', [1, 2]],
            t4: ['l', [4, 7]],
            d: ['d', [1, 1]]
        };
        var recipes = [
            [['p', 4], [['l', 1]]],
        ];
        var inventory = [];
        var walkable = ['g', 'd', 't0'];
        var blocks = [];
        var screenNum = 0;
        //spawn, map size
        var xpos = 50, ypos = 50, height = 100, width = 100;

        function addDetail(xx, yy, src) {
            blocks[yy][xx] = src;
        }
        function fillAll(src) {
            for (var row = 0; row < height; row++) {
                for (var tile = 0; tile < width; tile++) {
                    blocks[width][tile] = src;
                }
            }
        }
        function fillRandom(k) {
            var total = 0;
            for (l in k) {
                total += k[l][1];
            }
            for (var row = 0; row < height; row++) {
                for (var tile = 0; tile < width; tile++) {
                    var p = Math.random() * total, c = 0;
                    for (m in k) {
                        c += k[m][1]
                        if (p < c) {
                            blocks[row][tile] = k[m][0];
                            break;
                        }
                    }
                }
            }
        }
        function randompatch(cx, cy, r, src) {
            for (var dx = cx - r; dx < cx + r; dx++) {
                for (var dy = cy - r; dy < cy + r; dy++) {
                    if (((((cy - dy) ** 2) + ((cx - dx) ** 2)) ** (1 / 2) < r - 1) || ((((cy - dy) ** 2) + ((cx - dx) ** 2)) ** (1 / 2) < r + 1 && Math.random() > 0.5)) {
                        blocks[dy][dx] = src;
                    }
                }
            }
        }

        function startGame() {
            myGameArea.start();
            for (var i = 0; i < height; i++) {
                blocks[i] = [];
            }
            myGameArea.context.imageSmoothingEnabled = false;
        }
        var myGameArea = {
            keys: [],
            getc: function () {
                return blocks[Math.floor(ypos + this.y / 100 - 3)][Math.floor(xpos + this.x / 100 - 3)];
            },
            setc: function (e) {
                blocks[Math.floor(ypos + myGameArea.y / 100 - 3)][Math.floor(xpos + myGameArea.x / 100 - 3)] = e;
            },
            add: function (c, n) {
                var p = 0;
                for (var x = 0; x < inventory.length; x++) {
                    if (inventory[x][0] == c) {
                        inventory[x][1] += n;
                        p = 1;
                        break;
                    }
                }
                if (p == 0) {
                    inventory.push([c, n]);
                }
            },
            start: function () {
                document.getElementById("canvas").width = 700;
                document.getElementById("canvas").height = 700;
                this.context = document.getElementById("canvas").getContext("2d");
                img.src = 'player-sprite.png';
                img.onload = function () {
                    setInterval(updateGameArea, 20);
                };
                window.addEventListener('keydown', function (e) {
                    myGameArea.keys = (myGameArea.keys || []);
                    myGameArea.keys[e.keyCode] = (e.type == "keydown");
                })
                window.addEventListener('keyup', function (e) {
                    myGameArea.keys[e.keyCode] = (e.type == "keydown");
                })
                window.addEventListener('mousedown', function (e) {
                    myGameArea.x = e.clientX * 70000 / (98 * window.innerHeight);
                    myGameArea.y = e.clientY * 70000 / (98 * window.innerHeight);
                    myGameArea.click = true;
                })
                window.addEventListener('mousemove', function (e) {
                    myGameArea.x = e.clientX * 70000 / (98 * window.innerHeight);
                    myGameArea.y = e.clientY * 70000 / (98 * window.innerHeight);
                })
                window.addEventListener('mouseup', function (e) {
                    myGameArea.x = false;
                    myGameArea.y = false;
                    myGameArea.click = false;
                })
                window.addEventListener('touchstart', function (e) {
                    myGameArea.x = e.clientX * 70000 / (98 * window.innerHeight);
                    myGameArea.y = e.clientY * 70000 / (98 * window.innerHeight);
                })
                window.addEventListener('touchmove', function (e) {
                    myGameArea.x = e.touches[0].clientX * 70000 / (98 * window.innerHeight);
                    myGameArea.y = e.touches[0].clientY * 70000 / (98 * window.innerHeight);
                })
                window.addEventListener('touchend', function (e) {
                    myGameArea.x = false;
                    myGameArea.y = false;
                })
            },
            clear: function () {
                this.context.clearRect(0, 0, document.getElementById("canvas").width, document.getElementById("canvas").height);
            }
        }
        function renderBlocks() {
            var ctx = myGameArea.context;
            for (var r = 0; r < blocks.length; r++) {
                for (var c = 0; c < blocks.length; c++) {
                    //very important, makes sure only visible tiles are rendered, saving huge amounts of time and lag.
                    if ((c - xpos + 3) * 100 <= 800 && (c - xpos + 3) * 100 >= -100 && (r - ypos + 3) * 100 <= 800 && (r - ypos + 3) * 100 >= -100) {
                        var imgs = new Image();
                        imgs.src = 'tiles/tiles-1.png';
                        var d = chooseBlock(blocks[r][c]);
                        ctx.drawImage(imgs, d[0] * 32, d[1] * 32, 32, 32, (c - xpos + 3) * 100, (r - ypos + 3) * 100, 100, 100);
                    }
                }
            }
        }
        function chooseBlock(e) {
            var dx, dy;
            switch (e) {
                case 'g':
                    dx = 0;
                    dy = 0;
                    break;
                case 't0':
                    dx = 1;
                    dy = 0;
                    break;
                case 't2':
                    dx = 2;
                    dy = 0;
                    break;
                case 't3':
                    dx = 3;
                    dy = 0;
                    break;
                case 't1':
                    dx = 4;
                    dy = 0;
                    break;
                case 't4':
                    dx = 0;
                    dy = 1;
                    break;
                case 'r':
                    dx = 1;
                    dy = 1;
                    break;
                case 'd':
                    dx = 2;
                    dy = 1;
                    break;
                case 'l':
                    dx = 3;
                    dy = 1;
                    break;
                case 's':
                    dx = 4;
                    dy = 1;
                    break;
                case 'p':
                    dx = 0;
                    dy = 2;
                    break;
                /* decides what to render. Each tile has 1-4 letter shorthand. syntax:
                case <shorthand>:
                    dx = <xpos in sheet>;
                    dy = <ypos in sheet>;
                    break;
                */
            }
            return [dx, dy];
        }
        function left() {
            if (walkable.includes(blocks[(Math.floor(ypos))][Math.ceil(xpos + 0.0625)]) && walkable.includes(blocks[(Math.ceil(ypos))][Math.ceil(xpos + 0.0625)])) {
                xpos += 0.0625;
                if (xpos >= width - 4) {
                    xpos = width - 4;
                }
            }
        }
        function right() {
            if (walkable.includes(blocks[(Math.floor(ypos))][Math.floor(xpos - 0.0625)]) && walkable.includes(blocks[(Math.ceil(ypos))][Math.floor(xpos - 0.0625)])) {
                xpos -= 0.0625;
                if (xpos <= 3) {
                    xpos = 3;
                }
            }
        }
        function up() {
            if (walkable.includes(blocks[(Math.floor(ypos - 0.0625))][Math.floor(xpos)]) && walkable.includes(blocks[(Math.floor(ypos - 0.0625))][Math.ceil(xpos)])) {
                ypos -= 0.0625;
                if (ypos <= 3) {
                    ypos = 3;
                }
            }
        }
        function down() {
            if (walkable.includes(blocks[(Math.ceil(ypos + 0.0625))][Math.floor(xpos)]) && walkable.includes(blocks[(Math.ceil(ypos + 0.0625))][Math.ceil(xpos)])) {
                ypos += 0.0625;
                if (ypos >= height - 4) {
                    ypos = height - 4;
                }
            }
        }
        var lastClick = {
            x: -1,
            y: -1
        }, clickCount = 1;
        function updateGameArea() {
            myGameArea.clear();
            if (screenNum == 0) {
                var bImage = new Image();
                bImage.src = '../frontpageandmainfiles/index wp.png'
                myGameArea.context.drawImage(bImage, 0, 0, 700, 700);
                if (myGameArea.x && myGameArea.y && myGameArea.x > 286 && myGameArea.y > 286 && myGameArea.x < 413 && myGameArea.y < 413 && myGameArea.click) {
                    loadTiles();
                    screenNum = 1;
                }
            } else if (screenNum == 1) {
                let hasMoved = false;
                if (myGameArea.click && myGameArea.x < 700 && myGameArea.x > 0 && myGameArea.y < 700 && myGameArea.y > 0) {
                    if (lastClick.x != Math.floor(xpos + myGameArea.x / 100 - 3) || lastClick.y != Math.floor(ypos + myGameArea.y / 100 - 3)) {
                        clickCount = 1;
                    } else {
                        clickCount += 1;
                    }
                    myGameArea.click = false;
                    if (clickCount == maxClicks[myGameArea.getc()]) {
                        myGameArea.add(dropitem[myGameArea.getc()][0], Math.floor(Math.random() * (dropitem[myGameArea.getc()][1][1] - dropitem[myGameArea.getc()][1][0] + 1)) + dropitem[myGameArea.getc()][1][0]);
                        myGameArea.setc('g');
                    }
                    lastClick.x = Math.floor(xpos + myGameArea.x / 100 - 3);
                    lastClick.y = Math.floor(ypos + myGameArea.y / 100 - 3);
                }
                if (myGameArea.keys && (myGameArea.keys[37] || myGameArea.keys[97] || myGameArea.keys[65])) {
                    right();
                    currentDirection = FACING_LEFT;

                    hasMoved = true;
                } else if (myGameArea.keys && (myGameArea.keys[39] || myGameArea.keys[100] || myGameArea.keys[68])) {
                    left();
                    hasMoved = true;
                    currentDirection = FACING_RIGHT;
                }
                if (myGameArea.keys && (myGameArea.keys[38] || myGameArea.keys[119] || myGameArea.keys[87])) {
                    currentDirection = FACING_UP;
                    up();
                    hasMoved = true;
                } else if (myGameArea.keys && (myGameArea.keys[40] || myGameArea.keys[115] || myGameArea.keys[83])) {
                    down();
                    hasMoved = true;
                    currentDirection = FACING_DOWN;
                }
                if (hasMoved) {
                    frameCount++;
                    if (frameCount >= FRAME_LIMIT) {
                        frameCount = 0;
                        currentLoopIndex++;
                        if (currentLoopIndex >= CYCLE_LOOP.length) {
                            currentLoopIndex = 0;
                        }
                    }
                }

                if (!hasMoved) {
                    currentLoopIndex = 0;
                }
                renderBlocks();

                drawFrame(CYCLE_LOOP[currentLoopIndex], currentDirection, 300, 300);
                if (myGameArea.keys && (myGameArea.keys[69] || myGameArea.keys[101])) {
                    screenNum = 2;
                    myGameArea.keys[101] = false;
                    myGameArea.keys[69] = false;
                }
            } else if (screenNum == 2) {
                if ((myGameArea.click && myGameArea.x > 650 && myGameArea.x < 700 && myGameArea.y < 50) || (myGameArea.keys && (myGameArea.keys[69] || myGameArea.keys[101]))) {
                    screenNum = 1;
                    myGameArea.keys[101] = false;
                    myGameArea.keys[69] = false;
                }
                myGameArea.context.fillStyle = '#000066';
                myGameArea.context.fillRect(0, 0, 700, 700);
                for (var x = 0; x < inventory.length; x++) {
                    var gx = chooseBlock(inventory[x][0])[0] * 32, gy = chooseBlock(inventory[x][0])[1] * 32;
                    var img = new Image();
                    img.src = 'tiles/tiles-1.png';
                    myGameArea.context.fillStyle = 'grey';
                    myGameArea.context.fillRect(50 + (56 * x), 50, 56, 56);
                    myGameArea.context.fillStyle = 'black';
                    myGameArea.context.moveTo(52 + (56 * x), 52);
                    myGameArea.context.lineTo(104 + (56 * x), 52);
                    myGameArea.context.lineTo(104 + (56 * x), 104);
                    myGameArea.context.lineTo(52 + (56 * x), 104);
                    myGameArea.context.lineTo(52 + (56 * x), 52);
                    myGameArea.context.stroke();
                    myGameArea.context.drawImage(img, gx, gy, 32, 32, 53 + (56 * x), 53, 50, 50);
                    myGameArea.context.font = '15px Arial';
                    myGameArea.context.fillStyle = 'white';
                    myGameArea.context.fillText(inventory[x][1], 80 + x * 50, 100);
                }
                //inventory[p][1] >= recipes[x][1][m][1]
                var arec = [];
                for (var x = 0; x < recipes.length; x++) {
                    var o = 0;
                    for (var m = 0; m < recipes[x][1].length; m++) {
                        var t = [];
                        for (var p = 0; p < inventory.length; p++) {
                            t.push(inventory[p][0]);
                        }
                        if (t.indexOf(recipes[x][1][m][0]) == -1 || inventory[t.indexOf(recipes[x][1][m][0])][1] < recipes[x][1][m][1]) {
                            o = 1;
                            console.log(t, recipes[x][1][m][0])
                        }
                    }
                    if (o == 0) {
                        arec.push(recipes[x][0][0]);
                    }
                }
                for (var q in arec) {
                    var gx = chooseBlock(recipes[q][0][0])[0] * 32, gy = chooseBlock(recipes[q][0][0])[1] * 32;
                    var img = new Image();
                    img.src = 'tiles/tiles-1.png';
                    myGameArea.context.fillStyle = 'grey';
                    myGameArea.context.fillRect(50 + (56 * (q % 8)), 250 + 56 * Math.floor(q/8), 56, 56);
                    myGameArea.context.fillStyle = 'black';
                    myGameArea.context.moveTo(52 + (56 * (q % 8)), 252 + 56 * Math.floor(q / 8));
                    myGameArea.context.lineTo(104 + (56 * (q % 8)), 252 + 56 * Math.floor(q / 8));
                    myGameArea.context.lineTo(104 + (56 * (q % 8)), 304 + 56 * Math.floor(q / 8));
                    myGameArea.context.lineTo(52 + (56 * (q % 8)), 304 + 56 * Math.floor(q / 8));
                    myGameArea.context.lineTo(52 + (56 * (q % 8)), 252 + 56 * Math.floor(q / 8));
                    myGameArea.context.stroke();
                    myGameArea.context.font = '15px Arial';
                    myGameArea.context.fillStyle = 'white';
                    myGameArea.context.drawImage(img, gx, gy, 32, 32, 53 + (56 * q), 253, 50, 50);
                    myGameArea.context.fillText(recipes[q][0][1], 80 + (q % 8) * 50, 300 + 50 * Math.floor(q / 8));
                }
            }
        }
        const CYCLE_LOOP = [0, 1, 0, 2];
        const FACING_DOWN = 2;
        const FACING_UP = 0;
        const FACING_LEFT = 3;
        const FACING_RIGHT = 1;
        const FRAME_LIMIT = 12;


        let currentDirection = FACING_DOWN;
        let currentLoopIndex = 0;
        let frameCount = 0;
        let positionX = 0;
        let positionY = 0;
        let img = new Image();
        function drawFrame(frameX, frameY, canvasX, canvasY) {
            myGameArea.context.drawImage(img,
                frameX * 128, frameY * 128, 128, 128,
                canvasX, canvasY, 100, 100);
        }
    </script>
    <script src="tileLoad.js"></script>
    <canvas id="canvas"></canvas>
</body>
</html>