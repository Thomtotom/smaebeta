<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        canvas {
            border: 1px solid #d3d3d3;
            background-color: #f1f1f1;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            height: 100vh;
        }

        #player {
            transform: translate(-482px,-226px);
            width: 260px;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body onload="startGame()">
    <script>var walkable = ['g','d','t0'];
        var blocks = [];
        var screenNum = 0;
//spawn, map size
        var xpos = 17, ypos = 4, height = 32, width = 32;

        function addDetail(xx, yy, src) {
            blocks[(yy * width) + xx] = src;
        }
        function fillAll(src) {
            for (var row = 0; row < height; row++) {
                for (var tile = 0; tile < width; tile++) {
                    blocks[(width * row) + tile] = src;
                }
            }
        }
        function randompatch(cx, cy, r, src) {
            for (var dx = cx - r; dx < cx + r; dx++) {
                for (var dy = cy - r; dy < cy + r; dy++) {
                    if (((((cy - dy) ** 2) + ((cx - dx) ** 2)) ** (1 / 2) < r - 1) || ((((cy - dy) ** 2) + ((cx - dx) ** 2)) ** (1 / 2) < r + 1 && Math.random() > 0.5)) {
                        blocks[(dy * width) + dx] = src;
                    }
                }
            }
        }

        function startGame() {
            myGameArea.start();
        }
        var myGameArea = {
            keys: [],
            start: function () {
                document.getElementById("canvas").width = 700;
                document.getElementById("canvas").height = 700;
                this.context = document.getElementById("canvas").getContext("2d");
                img.src = 'player-sprite.png';
                img.onload = function () {
                    window.requestAnimationFrame(updateGameArea);
                };
                window.addEventListener('keydown', function (e) {
                    myGameArea.keys = (myGameArea.keys || []);
                    myGameArea.keys[e.keyCode] = (e.type == "keydown");
                })
                window.addEventListener('keyup', function (e) {
                    myGameArea.keys[e.keyCode] = (e.type == "keydown");
                })
                window.addEventListener('mousedown', function (e) {
                    myGameArea.x = e.clientX * 700 / window.innerHeight;
                    myGameArea.y = e.clientY * 700 / window.innerHeight;
                    myGameArea.click = true;
                })
                window.addEventListener('mousemove', function (e) {
                    myGameArea.x = e.clientX * 700 / window.innerHeight;
                    myGameArea.y = e.clientY * 700 / window.innerHeight;
                })
                window.addEventListener('mouseup', function (e) {
                    myGameArea.x = false;
                    myGameArea.y = false;
                    myGameArea.click = false;
                })
                window.addEventListener('touchstart', function (e) {
                    myGameArea.x = e.clientX * 700 / window.innerHeight;
                    myGameArea.y = e.clientY * 700 / window.innerHeight;
                })
                window.addEventListener('touchmove', function (e) {
                    myGameArea.x = e.touches[0].clientX * 700 / window.innerHeight;
                    myGameArea.y = e.touches[0].clientY * 700 / window.innerHeight;
                })
                window.addEventListener('touchend', function (e) {
                    myGameArea.x = false;
                    myGameArea.y = false;
                })
            },
            clear: function () {
                this.context.clearRect(0, 0, document.getElementById("canvas").width, document.getElementById("canvas").height);
            }
        }
        function renderBlocks() {
            var ctx = myGameArea.context;
            for (var l = 0; l < blocks.length; l++) {
                var rowDraw = Math.floor(l / width);
                var tileDraw = l % width;
                //very important, makes sure only visible tiles are rendered, saving huge amounts of time and lag.
                if ((tileDraw - xpos + 3) * 100 <= 800 && (tileDraw - xpos + 3) * 100 >= -100 && (rowDraw - ypos + 3) * 100 <= 800 && (rowDraw - ypos + 3) * 100 >= -100) {
                    var imgs = new Image();
                    imgs.src = 'tiles/tiles-1.png';
                    var dx, dy;
                    switch (blocks[l]) {
                        case 'g':
                            dx = 0;
                            dy = 0;
                            break;
                        case 't0':
                            dx = 1;
                            dy = 0;
                            break;
                        case 't2':
                            dx = 2;
                            dy = 0;
                            break;
                        case 't3':
                            dx = 3;
                            dy = 0;
                            break;
                        case 't1':
                            dx = 0;
                            dy = 1;
                            break;
                        case 't4':
                            dx = 1;
                            dy = 1;
                            break;
                        case 'r':
                            dx = 2;
                            dy = 1;
                            break;
                        case 'd':
                            dx = 3;
                            dy = 1;
                            break;
                            /* decides what to render. Each tile has 2-4 letter shorthand. syntax:
                        case <shorthand>:
                            dx = <xpos in sheet>;
                            dy = <ypos in sheet>;
                            break;
                     */
                    }
                    ctx.drawImage(imgs, dx * 32, dy * 32, 32, 32, (tileDraw - xpos + 3) * 100, (rowDraw - ypos + 3) * 100, 100, 100);
                }
            }
        }

        function left() {
            if (walkable.includes(blocks[(Math.floor(ypos) * width) + Math.ceil(xpos + 0.0625)]) && walkable.includes(blocks[(Math.ceil(ypos) * width) + Math.ceil(xpos + 0.0625)])) {

                xpos += 0.0625;
                if (xpos >= width - 1) {
                    xpos = width - 1;
                }
            }
        }
        function right() {
            if (walkable.includes(blocks[(Math.floor(ypos) * width) + Math.floor(xpos - 0.0625)]) && walkable.includes(blocks[(Math.ceil(ypos) * width) + Math.floor(xpos - 0.0625)])) {

                xpos -= 0.0625;
                if (xpos <= 0) {
                    xpos = 0;
                }
            }
        }
        function up() {
            if (walkable.includes(blocks[(Math.floor(ypos - 0.0625) * width) + Math.floor(xpos)]) && walkable.includes(blocks[(Math.floor(ypos - 0.0625) * width) + Math.ceil(xpos)])) {

                ypos -= 0.0625;
                if (ypos <= 0) {
                    ypos = 0;
                }
            }
        }
        function down() {
            if (walkable.includes(blocks[(Math.ceil(ypos + 0.0625) * width) + Math.floor(xpos)]) && walkable.includes(blocks[(Math.ceil(ypos + 0.0625) * width) + Math.ceil(xpos)])) {

                ypos += 0.0625;
                if (ypos >= height) {
                    ypos = height;
                }
            }
        }

        function updateGameArea() {
            myGameArea.clear();
            if (screenNum == 0) {
                var bImage = new Image();
                bImage.src = '../frontpageandmainfiles/index.png'
                myGameArea.context.drawImage(bImage, 0, 0, 700, 700);
                if (myGameArea.x && myGameArea.y && myGameArea.x > 286 && myGameArea.y > 286 && myGameArea.x < 413 && myGameArea.y < 413 && myGameArea.click) {
                    loadTiles();
                    screenNum = 1;
                }
            } else if (screenNum == 1) {
let hasMoved = false;

                    if ((myGameArea.keys && (myGameArea.keys[37] || myGameArea.keys[97] || myGameArea.keys[65])) || (myGameArea.x && myGameArea.x < 200 && myGameArea.click)) {
                        right();
                        currentDirection = FACING_LEFT;

                        hasMoved = true;
                    } else if ((myGameArea.keys && (myGameArea.keys[39] || myGameArea.keys[100] || myGameArea.keys[68])) || (myGameArea.x && myGameArea.x > 500 && myGameArea.click)) {
                        left();
                        hasMoved = true;
                        currentDirection = FACING_RIGHT;

                    }
                    if ((myGameArea.keys && (myGameArea.keys[38] || myGameArea.keys[119] || myGameArea.keys[87])) || (myGameArea.y && myGameArea.y < 200 && myGameArea.click)) {
                        currentDirection = FACING_UP;
                        up()
                        hasMoved = true;
                    } else if ((myGameArea.keys && (myGameArea.keys[40] || myGameArea.keys[115] || myGameArea.keys[83])) || (myGameArea.y && myGameArea.y > 500 && myGameArea.click)) {
                        down();
                        hasMoved = true;
                        currentDirection = FACING_DOWN;
                    }
                	if (hasMoved) {
    frameCount++;
    if (frameCount >= FRAME_LIMIT) {
      frameCount = 0;
      currentLoopIndex++;
      if (currentLoopIndex >= CYCLE_LOOP.length) {
        currentLoopIndex = 0;
      }
    }
  }

  if (!hasMoved) {
    currentLoopIndex = 0;
  }
                renderBlocks();

  					drawFrame(CYCLE_LOOP[currentLoopIndex], currentDirection, 300, 300);
                console.log('?')
                }
            window.requestAnimationFrame(updateGameArea);

            }
const CYCLE_LOOP = [0, 1, 0, 2];
const FACING_DOWN = 2;
const FACING_UP = 0;
const FACING_LEFT = 3;
const FACING_RIGHT = 1;
const FRAME_LIMIT = 12;


let currentDirection = FACING_DOWN;
let currentLoopIndex = 0;
let frameCount = 0;
let positionX = 0;
let positionY = 0;
let img = new Image();


function drawFrame(frameX, frameY, canvasX, canvasY) {
  myGameArea.context.drawImage(img,
                frameX * 32, frameY * 32, 32, 32,
                canvasX, canvasY, 100, 100);
}</script>
    <script src="tileLoad.js"></script>
    <canvas id="canvas"></canvas>
</body>
</html>
